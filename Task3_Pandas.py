# -*- coding: utf-8 -*-
"""Day 4-5 Pandas.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eYKp1tJZf-oEw3_IUEMwdjrL5il5KP3X

# (Part 1): Getting Started with Data Analysis - Installation and Loading Data
"""

pip install pandas

pip install jupyter lab

import pandas as pd


df = pd.read_csv('/content/survey_results_public.csv')

df
df.shape #to find out number of (rows,columns)
df.info() # to see all the columns since too many
 
pd.set_option('display.max_columns', 85)
pd.set_option('display.max_rows', 85)

schema_df = pd.read_csv('/content/survey_results_schema.csv')
schema_df

"""# (Part 2): DataFrame and Series Basics - Selecting Rows and Columns"""

people = {
    "first": ["Corey", 'Jane', 'John'], 
    "last": ["Schafer", 'Doe', 'Doe'], 
    "email": ["CoreyMSchafer@gmail.com", 'JaneDoe@email.com', 'JohnDoe@email.com']
}
people['email']


import pandas as pd

df = pd.DataFrame(people)

df


df['email']
df.email   # same as ^


df[['last', 'email']]

df.columns

df.iloc[[0, 1], 2] # allows u to access by integer location, 1st part is rows then its column

df

df.loc[[0, 1], ['email', 'last']]

"""# (Part 3): Indexes - How to Set, Reset, and Use Indexes"""

people = {
    "first": ["Corey", 'Jane', 'John'], 
    "last": ["Schafer", 'Doe', 'Doe'], 
    "email": ["CoreyMSchafer@gmail.com", 'JaneDoe@email.com', 'JohnDoe@email.com']
}

import pandas as pd

df = pd.DataFrame(people)

df

df['email']

df.set_index('email', inplace=True)

df

df.index

df.loc['CoreyMSchafer@gmail.com', 'last']

df.iloc[0]

df.reset_index(inplace=True)
df

"""#(Part 4): Filtering - Using Conditionals to Filter Rows and Columns"""

people = {
    "first": ["Corey", 'Jane', 'John'], 
    "last": ["Schafer", 'Doe', 'Doe'], 
    "email": ["CoreyMSchafer@gmail.com", 'JaneDoe@email.com', 'JohnDoe@email.com']
}

import pandas as pd

df = pd.DataFrame(people)

df

filt = (df['last'] == 'Doe')
#df[filt]
#df.loc[filt]
#df.loc[filt, 'email']
df

#filt = (df['last'] == 'Doe') & (df['first'] == 'John')      #&, |=or
filt = (df['last'] == 'Schafer') | (df['first'] == 'John')
df.loc[~filt, 'email']  #~ means opposite

"""#(Part 5): Updating Rows and Columns - Modifying Data Within DataFrames"""

people = {
    "first": ["Corey", 'Jane', 'John'], 
    "last": ["Schafer", 'Doe', 'Doe'], 
    "email": ["CoreyMSchafer@gmail.com", 'JaneDoe@email.com', 'JohnDoe@email.com']
}

import pandas as pd

df = pd.DataFrame(people)

df.columns = ['first_name', 'last_name', 'email']

df.columns = [x.lower() for x in df.columns]


df.rename(columns={'first_name': 'first', 'last_name': 'last'}, inplace=True)

df.loc[2] = ['John', 'Smith', 'JohnSmith@email.com']

df.loc[2, ['last', 'email']] = ['Doe', 'JohnDoe@email.com']

df.loc[2, 'last'] = 'Smith'

filt = (df['email'] == 'JohnDoe@email.com')
df.loc[filt, 'last'] = 'Smith'

df['email'] = df['email'].str.lower()

df

#df['email'].apply(len)

def update_email(email):
    return email.upper()

df['email'].apply(update_email)

df['email'] = df['email'].apply(update_email)
#df['email'] = df['email'].apply(lambda x: x.lower()) #to make it lowercase again

df

df['email'].apply(len) #counts characters of emails

df.apply(len, axis='columns') #counts the number od columns 

len(df['email']) #counts number of emails

df.apply(pd.Series.min)

df.apply(lambda x: x.min())

df.applymap(len) #makes chart of just #of letters 

df.applymap(str.lower) #makes everything lower

df['first'].map({'Corey': 'Chris', 'Jane': 'Mary'})  #changes names 

df['first'] = df['first'].replace({'Corey': 'Chris', 'Jane': 'Mary'})

df

"""#(Part 6): Add/Remove Rows and Columns From DataFrames"""

people = {
    'first': ['Corey', 'Jane', 'John'], 
    'last': ['Schafer', 'Doe', 'Doe'], 
    'email': ['CoreyMSchafer@gmail.com', 'JaneDoe@email.com', 'JohnDoe@email.com']
}

import pandas as pd

df = pd.DataFrame(people)

df['full_name'] = df['first'] + ' ' + df['last'] #adds fulll name column
df.drop(columns=['first', 'last'], inplace=True) 

df['full_name'].str.split(' ', expand=True) #full name column but split

df[['first', 'last']] = df['full_name'].str.split(' ', expand=True)

df

df.append({'first': 'Tony'}, ignore_index=True)

people = {
    'first': ['Tony', 'Steve'], 
    'last': ['Stark', 'Rogers'], 
    'email': ['IronMan@avenge.com', 'Cap@avenge.com']
}
df2 = pd.DataFrame(people)
df2

df.append(df2, ignore_index=True, sort=False)

df = df.append(df2, ignore_index=True, sort=False)    # adds to other list 

df.drop(index=4) #gets rid of 4the row

filt = df['last'] == 'Doe'
df.drop(index=df[filt].index)  #gets rid of the Does

"""# (Part 7): Sorting Data"""

people = {
    'first': ['Corey', 'Jane', 'John', 'Adam'], 
    'last': ['Schafer', 'Doe', 'Doe', 'Doe'], 
    'email': ['CoreyMSchafer@gmail.com', 'JaneDoe@email.com', 'JohnDoe@email.com', 'A@email.com']
}

import pandas as pd

df = pd.DataFrame(people)

df.sort_values(by='last') #sort by last name alphabetically 
df.sort_values(by='last', ascending=False) #sorts z-a
        
df.sort_values(by=['last', 'first'], ascending=False) #sorts desendingly including first name (jane on bottom now)

df.sort_values(by=['last', 'first'], ascending=[False, True], inplace=True) #sorts des. but first name in asc. , inplace save it 

df.sort_index()  #brings it back to how it was based on index #

df['last'].sort_values() #just sorts the last name and singles it out

df.sort_values(by=['Country', 'ConvertedComp'], ascending=[True, False], inplace=True)
#sorts the countries a-z and Salaries from big to small
df[['Country', 'ConvertedComp']].head(50)  #head(50) means just show first 50

df['ConvertedComp'].nlargest(10) #for the 10 largest salaries 
df.nsmallest(10, 'ConvertedComp') #shows the other answers but in that order

"""# (Part 8): Grouping and Aggregating - Analyzing and Exploring Your Data

Aggregating-combining multiple peices of data into a single set.
"""

import pandas as pd

df = pd.read_csv('/content/survey_results_public.csv', index_col='Respondent')
schema_df = pd.read_csv('/content/survey_results_schema.csv', index_col='Column')

pd.set_option('display.max_columns', 85)
pd.set_option('display.max_rows', 85)

df.head()

df['ConvertedComp'].head(15) 
df['ConvertedComp'].median() #median salary 
df.median() # maedians of all columns 

df.describe() #all stats

df['ConvertedComp'].count() #count is the number of nonmissing rows

df['Hobbyist'] #show that column
df['Hobbyist'].value_counts() #to know how manny ppl answered yess or no

df['SocialMedia']

schema_df.loc['SocialMedia'] #to see what question as asked 

df['SocialMedia'].value_counts() #how many ppl answered what 

df['SocialMedia'].value_counts(normalize=True) #to get percentages

"""groupby - split, apply function, combine results : to see which app is most popular in each contry etc."""

df['Country'].value_counts()

country_grp = df.groupby(['Country']) #creates groups based on country 

country_grp.get_group('India') 

filt = df['Country'] == 'India'
df.loc[filt]['SocialMedia'].value_counts()  #to see the # of ppl from india on certain apps 

country_grp['SocialMedia'].value_counts().head(50) #to see each country and popular apps 

country_grp['SocialMedia'].value_counts().loc['India'] #same thing as 2 up but now eaiser to put in country 

#country_grp['SocialMedia'].value_counts(normalize=True).loc['China'] #normalize gives you percents

country_grp['ConvertedComp'].median() #for median salary of each country 

country_grp['ConvertedComp'].median().loc['Germany'] #median for just germany

country_grp['ConvertedComp'].agg(['median', 'mean']).loc['Canada']

filt = df['Country'] == 'India'
df.loc[filt]['LanguageWorkedWith'].str.contains('Python').sum() #to find # of ppl from india using python 

#country_grp['LanguageWorkedWith'].str.contains('Python').sum()    #gives u error

country_grp['LanguageWorkedWith'].apply(lambda x: x.str.contains('Python').sum()) #now u can see each contry and # of ppl using python w/o error.

"""What percent of ppl from each country know python?"""

country_respondents = df['Country'].value_counts() #of ppl in each country
country_respondents

country_uses_python = country_grp['LanguageWorkedWith'].apply(lambda x: x.str.contains('Python').sum()) #pthon useres in each contry
country_uses_python

python_df = pd.concat([country_respondents, country_uses_python], axis='columns', sort=False) #sort=false makes it not sort automatically 
python_df
#creates a chart of total#of ppl from each country and #of ppl using python

python_df.rename(columns={'Country': 'NumRespondents', 'LanguageWorkedWith': 'NumKnowsPython'}, inplace=True)  # renames columns 
python_df

python_df['PctKnowsPython']=(python_df['NumKnowsPython']/python_df['NumRespondents'])*100
python_df
python_df.sort_values(by='PctKnowsPython', ascending=False, inplace=True) #to get the highest poerecent on top
python_df.head(50)

python_df.loc['Japan'] #to just get Japan

"""# (Part 9): Cleaning Data - Casting Datatypes and Handling Missing Value"""

import pandas as pd

df = pd.read_csv('/content/survey_results_public.csv', index_col='Respondent',  na_values=na_vals)
schema_df = pd.read_csv('/content/survey_results_schema.csv', index_col='Column')
na_vals = ['NA', 'Missing']

pd.set_option('display.max_columns', 85)
pd.set_option('display.max_rows', 85)

df.head()

df['YearsCode'].head(10)
df['YearsCode'].unique()

df['YearsCode'].replace('Less than 1 year', 0, inplace=True)

df['YearsCode'].replace('More than 50 years', 51, inplace=True)

df['YearsCode'] = df['YearsCode'].astype(float)

df['YearsCode'].mean()
df['YearsCode'].median()